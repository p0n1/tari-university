<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Schnorr Signatures - Tari Labs University</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A collection of learning resources for cryptocurrency">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <!-- Twitter tags -->
        <meta name="twitter:title" content="Introduction to Schnorr Signatures - Tari Labs University" />
        <meta name="twitter:site" content="Introduction to Schnorr Signatures - Tari Labs University"/>
        <meta name="twitter:description" content="A collection of learning resources for cryptocurrency" />
        <meta name="twitter:image" content="https://tlu.tarilabs.com/theme/images/tari-labs.png" />
        <meta name="twitter:card" content="summary"/>

        <!-- Facebook tags -->
        <meta property="og:title" content="Introduction to Schnorr Signatures - Tari Labs University" />
        <meta property="og:site_name" content="Introduction to Schnorr Signatures - Tari Labs University"/>
        <meta property="og:image" content="https://tlu.tarilabs.com/theme/images/tari-labs.png" />
        <meta property="og:description" content="A collection of learning resources for cryptocurrency" />

        <!-- Generic tags -->
        <meta itemprop="thumbnailUrl" content="https://tlu.tarilabs.com/theme/images/tari-labs.png"/>
        <meta itemprop="image" content="https://tlu.tarilabs.com/theme/images/tari-labs.png"/>
        <link rel="image_src" href="https://tlu.tarilabs.com/theme/images/tari-labs.png"/>

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>
        

        <style>
        div.wrap_beg {
            width: 95%; 
            word-wrap: break-word;
            background: #FFE599;
            font-size: 1.0em;
            padding: 0.5em;
            color: #000000;
            }
        </style>
        <style>
        div.wrap_int {
            width: 95%; 
            word-wrap: break-word;
            background: #B6D7A8;
            font-size: 1.0em;
            padding: 0.5em;
            color: #000000;
            }
        </style>
        <style>
            div.wrap_adv {
            width: 95%; 
            word-wrap: break-word;
            background: #A2C4C9;
            font-size: 1.0em;
            padding: 0.5em;
            color: #000000;
            }
        </style>

    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img src="../../theme/images/tlu.png" class="tlu">

            <ol class="chapter"><li class="expanded affix "><a href="../../preface/introduction.html">Introduction</a></li><li class="expanded "><a href="../../preface/learning/introduction-to-learning.html"><strong aria-hidden="true">1.</strong> Learning Paths</a></li><li><ol class="section"><li class="expanded "><a href="../../preface/learning/blockchain-basics.html"><strong aria-hidden="true">1.1.</strong> Learning about Blockchain Basics</a></li><li class="expanded "><a href="../../preface/learning/mimblewimble.html"><strong aria-hidden="true">1.2.</strong> Learning about Mimblewimble Implementation</a></li><li class="expanded "><a href="../../preface/learning/bulletproofs.html"><strong aria-hidden="true">1.3.</strong> Learning about Bulletproofs</a></li></ol></li><li class="expanded "><a href="../../cryptography/cryptography.html"><strong aria-hidden="true">2.</strong> Cryptography</a></li><li><ol class="section"><li class="expanded "><a href="../../cryptography/crypto-1/sources/PITCHME.link.html"><strong aria-hidden="true">2.1.</strong> Elliptic Curves 101</a></li><li class="expanded "><a href="../../cryptography/digital_signatures/introduction_schnorr_signatures.html" class="active"><strong aria-hidden="true">2.2.</strong> Introduction to Schnorr Signatures</a></li><li class="expanded "><a href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html"><strong aria-hidden="true">2.3.</strong> Introduction to Scriptless Scripts</a></li><li class="expanded "><a href="../../cryptography/musig-schnorr-sig-scheme/The_MuSig_Schnorr_Signature_Scheme.html"><strong aria-hidden="true">2.4.</strong> The MuSig Schnorr Signature Scheme</a></li><li class="expanded "><a href="../../cryptography/fraud-proofs-1/MainReport.html"><strong aria-hidden="true">2.5.</strong> Fraud Proofs</a></li><li class="expanded "><a href="../../cryptography/bulletproofs-and-mimblewimble/MainReport.html"><strong aria-hidden="true">2.6.</strong> Bulletproofs and Mimblewimble</a></li><li class="expanded "><a href="../../cryptography/building-on-bulletproofs/link.html"><strong aria-hidden="true">2.7.</strong> Building on Bulletproofs</a></li><li class="expanded "><a href="../../cryptography/bulletproofs-protocols/MainReport.html"><strong aria-hidden="true">2.8.</strong> The Bulletproof Protocols</a></li><li class="expanded "><a href="../../cryptography/pure-rust-ecc/pure-rust-ecc.html"><strong aria-hidden="true">2.9.</strong> Pure-Rust Elliptic Curve Cryptography</a></li><li class="expanded "><a href="../../cryptography/zksnarks/mainreport.html"><strong aria-hidden="true">2.10.</strong> zk-SNARKs</a></li><li class="expanded "><a href="../../cryptography/r1cs-bulletproofs/mainreport.html"><strong aria-hidden="true">2.11.</strong> Rank-1 Constraint System with Application to Bulletproofs</a></li></ol></li><li class="expanded "><a href="../../consensus-mechanisms/consensus-mechanisms.html"><strong aria-hidden="true">3.</strong> Consensus Mechanisms</a></li><li><ol class="section"><li class="expanded "><a href="../../consensus-mechanisms/BFT/understanding_bft_consensus.html"><strong aria-hidden="true">3.1.</strong> Understanding BFT Consensus</a></li><li class="expanded "><a href="../../consensus-mechanisms/BFT-consensusmechanisms/sources/PITCHME.link.html"><strong aria-hidden="true">3.2.</strong> BFT Consensus Mechanisms</a></li><li class="expanded "><a href="../../consensus-mechanisms/BFT-consensus-mechanisms-applications/MainReport.html"><strong aria-hidden="true">3.3.</strong> Introduction to Applications of Byzantine Consensus Mechanisms</a></li></ol></li><li class="expanded "><a href="../../scaling/scaling.html"><strong aria-hidden="true">4.</strong> Scaling</a></li><li><ol class="section"><li class="expanded "><a href="../../scaling/layer2scaling-landscape/layer2scaling-survey.html"><strong aria-hidden="true">4.1.</strong> Layer 2 Scaling Survey</a></li><li class="expanded "><a href="../../scaling/executive-summary/sources/PITCHME.link.html"><strong aria-hidden="true">4.2.</strong> Layer 2 Scaling Survey Executive Summary</a></li><li class="expanded "><a href="../../scaling/directed-acyclic-graphs/DAGs.html"><strong aria-hidden="true">4.3.</strong> Directed Acyclic Graphs</a></li><li class="expanded "><a href="../../scaling/laser-beam/MainReport.html"><strong aria-hidden="true">4.4.</strong> Laser Beam</a></li></ol></li><li class="expanded "><a href="../../merged-mining/merged-mining.html"><strong aria-hidden="true">5.</strong> Merged Mining</a></li><li><ol class="section"><li class="expanded "><a href="../../merged-mining/merged-mining-scene/MergedMiningIntroduction.html"><strong aria-hidden="true">5.1.</strong> Merged Mining Introduction</a></li></ol></li><li class="expanded "><a href="../../digital-assets/digital-assets.html"><strong aria-hidden="true">6.</strong> Digital Assets</a></li><li><ol class="section"><li class="expanded "><a href="../../digital-assets/howey-application-to-blockchain/MainReport.html"><strong aria-hidden="true">6.1.</strong> Application of Howey to Blockchain Network Token Sales</a></li><li class="expanded "><a href="../../digital-assets/nft-landscape-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.2.</strong> Non-fungible Tokens Survey</a></li><li class="expanded "><a href="../../digital-assets/confidential-assets/MainReport.html"><strong aria-hidden="true">6.3.</strong> Confidential Assets</a></li></ol></li><li class="expanded "><a href="../../protocols/protocols.html"><strong aria-hidden="true">7.</strong> Protocols</a></li><li><ol class="section"><li class="expanded "><a href="../../protocols/mimblewimble-1/sources/PITCHME.link.html"><strong aria-hidden="true">7.1.</strong> Mimblewimble A High-Level Overview</a></li><li class="expanded "><a href="../../protocols/mimblewimble-1/MainReport.html"><strong aria-hidden="true">7.2.</strong> Mimblewimble Transactions Explained</a></li><li class="expanded "><a href="../../protocols/grin-protocol-overview/MainReport.html"><strong aria-hidden="true">7.3.</strong> Mimblewimble-Grin Block Chain Protocol Overview</a></li><li class="expanded "><a href="../../protocols/grin-beam-comparison/MainReport.html"><strong aria-hidden="true">7.4.</strong> Grin vs. BEAM; a Comparison</a></li><li class="expanded "><a href="../../protocols/grin-design-choice-criticisms/MainReport.html"><strong aria-hidden="true">7.5.</strong> Grin Design Choice Criticisms - Truth or Fiction</a></li><li class="expanded "><a href="../../protocols/atomic-swaps/AtomicSwaps.html"><strong aria-hidden="true">7.6.</strong> Atomic Swaps</a></li><li class="expanded "><a href="../../protocols/lightning-network-for-dummies/sources/PITCHME.link.html"><strong aria-hidden="true">7.7.</strong> Lightning Network for Dummies</a></li><li class="expanded "><a href="../../protocols/merkle-trees-and-spv-1/sources/PITCHME.link.html"><strong aria-hidden="true">7.8.</strong> Introduction to SPV, Merkle Trees and Bloom Filters</a></li><li class="expanded "><a href="../../protocols/rgb-introduction/sources/PITCHME.link.html"><strong aria-hidden="true">7.9.</strong> The RGB Protocol - An Introduction</a></li><li class="expanded "><a href="../../protocols/intro-to-tor-i2P/MainReport.html"><strong aria-hidden="true">7.10.</strong> Introduction to Tor and I2P</a></li><li class="expanded "><a href="../../protocols/dht/MainReport.html"><strong aria-hidden="true">7.11.</strong> Distributed Hash Tables</a></li><li class="expanded "><a href="../../protocols/mimblewimble-mp-bp-utxo/MainReport.html"><strong aria-hidden="true">7.12.</strong> Mimblewimble Multiparty Bulletproof UTXO</a></li></ol></li><li class="expanded "><a href="../../network-analysis/network-analysis.html"><strong aria-hidden="true">8.</strong> Network Analysis</a></li><li><ol class="section"><li class="expanded "><a href="../../network-analysis/probabilistic-attack/building_blocks.html"><strong aria-hidden="true">8.1.</strong> Probabilistic Attack Vector Analysis Building Blocks</a></li><li class="expanded "><a href="../../network-analysis/probabilistic-attack/byzantine_takeover_of_the_DAN.html"><strong aria-hidden="true">8.2.</strong> Probability of a Byzantine Takeover of the Digital Assets Network</a></li></ol></li><li class="expanded "><a href="../../labs/introduction.html"><strong aria-hidden="true">9.</strong> Labs</a></li><li><ol class="section"><li class="expanded "><a href="../../labs/mermaid-demo.html"><strong aria-hidden="true">9.1.</strong> Mermaid Demonstration</a></li><li class="expanded "><a href="../../labs/notes.html"><strong aria-hidden="true">9.2.</strong> Notes and info boxes</a></li></ol></li><li class="expanded "><a href="../../preface/style-guide.html"><strong aria-hidden="true">10.</strong> Style Guide</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">
<svg width="23px" height="23px" viewBox="0 0 23 23 version="1.1" class="gem" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M0,6.12859037 L0,12.5315952 L9.50941704,23 L23,12.5722492 L23,6.12859037 L9.56098655,0 L0,6.12859037 Z M8.37488789,18.3349536 L2.3103139,11.6575342 L2.3103139,8.02916483 L8.37488789,9.56385329 L8.37488789,18.3349536 Z M10.6748879,19.2090146 L10.6748879,10.1533363 L19.4932735,12.3893062 L10.6748879,19.2090146 Z M20.7,7.57180734 L20.7,10.3464428 L4.17713004,6.15908087 L9.74663677,2.58152894 L20.7,7.57180734 Z" id="Shape" fill="#000000" fill-rule="nonzero"></path>
    </g>
</svg></h1> 

                        <div class="right-buttons">
                            <a href="../../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction-to-schnorr-signatures" id="introduction-to-schnorr-signatures">Introduction to Schnorr Signatures</a></h1>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#lets-get-started">Let's get Started</a></li>
<li><a href="#basics-of-schnorr-signatures">Basics of Schnorr Signatures</a>
<ul>
<li><a href="#public-and-private-keys">Public and Private Keys</a></li>
<li><a href="#creating-a-signature">Creating a Signature</a>
<ul>
<li><a href="#approach-taken">Approach Taken</a></li>
<li><a href="#why-do-we-need-the-nonce">Why do we Need the Nonce?</a></li>
<li><a href="#ecdh">ECDH</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#schnorr-signatures">Schnorr Signatures</a>
<ul>
<li><a href="#so-why-all-the-fuss">So why all the Fuss?</a></li>
<li><a href="#na%C3%AFve-signature-aggregation">(Naïve) Signature Aggregation</a></li>
<li><a href="#key-cancellation-attack">Key Cancellation Attack</a></li>
<li><a href="#better-approaches-to-aggregation">Better Approaches to Aggregation</a></li>
</ul>
</li>
<li><a href="#musig">MuSig</a>
<ul>
<li><a href="#musig-demonstration">MuSig Demonstration</a></li>
<li><a href="#security-demonstration">Security Demonstration</a></li>
<li><a href="#replay-attacks">Replay Attacks!</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
<li><a href="#contributors">Contributors</a></li>
</ul>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>Private-public key pairs are the cornerstone of much of the
cryptographic security underlying everything from secure web browsing to banking to cryptocurrencies. Private-public key pairs
are <em>asymmetric</em>. This means that given one of the numbers (the private key), it's possible to derive the other one 
(the public key). However, doing the reverse is not feasible. 
It's this asymmetry that allows one to share the public key, uh, publicly and be confident that no one can
figure out our private key (which we keep very secret and secure).</p>
<p>Asymmetric key pairs are employed in two main applications:</p>
<ul>
<li>in <em>authentication</em>, where you prove that you have knowledge of the private
key; and</li>
<li>in <em>encryption</em>, where messages can be encoded and only the person possessing the private key can decrypt and read the message.</li>
</ul>
<p>In this introduction to digital signatures, we'll be talking about a particular class of keys: those derived from 
elliptic curves. There are other asymmetric schemes, not least of which are those based on products of prime numbers, 
including RSA keys [<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" title="Wikipedia RSA Cryptography">1</a>].</p>
<p>We're going to assume you know the basics of elliptic curve cryptography (ECC). If not, don't stress, there's a
<a href="../crypto-1/sources/PITCHME.link.html">gentle introduction</a> in a previous chapter.</p>
<h2><a class="header" href="#lets-get-started" id="lets-get-started">Let's get Started</a></h2>
<p>This is an interactive introduction to digital signatures. It uses Rust code to demonstrate some of 
the ideas presented here, so you can see them at work. The code for this introduction uses the 
<a href="https://github.com/tari-labs/libsecp256k1">libsecp256k-rs</a> library. </p>
<p>That's a mouthful, but secp256k1 is the name of the elliptic curve that secures a <em>lot</em> of things in many
cryptocurrencies' transactions, including Bitcoin. </p>
<p>This particular library has some nice features. We've overridden the <code>+</code> (addition) and <code>*</code> (multiplication)
operators so that the Rust code looks a lot more like mathematical formulae. This makes it much easier
to play with the ideas we'll be exploring.</p>
<p><strong>WARNING!</strong> <em>Don't use this library in production code</em>. It hasn't been battle-hardened, so <a href="https://github.com/rust-bitcoin/rust-secp256k1">use this one in
production instead</a>.</p>
<h2><a class="header" href="#basics-of-schnorr-signatures" id="basics-of-schnorr-signatures">Basics of Schnorr Signatures</a></h2>
<h3><a class="header" href="#public-and-private-keys" id="public-and-private-keys">Public and Private Keys</a></h3>
<p>The first thing we'll do is create a public and private key from an elliptic curve.</p>
<p>On secp256k1, a private key is simply a scalar integer value between 0 and ~2<sup>256</sup>. That's roughly how many
atoms there are in the universe, so we have a big sandbox to play in.</p>
<p>We have a special point on the secp256k1 curve called <em>G</em>, which acts as the &quot;origin&quot;. A public key is calculated by 
adding <em>G</em> on the curve to itself, \( k_a \) times. This is the definition of multiplication by a scalar, and is
written as:
$$
P_a = k_a G
$$
Let's take an example from <a href="https://chuckbatson.wordpress.com/2014/11/26/secp256k1-test-vectors/">this post</a>, where
it is known that the public key for <code>1</code>, when written in uncompressed format, is <code>0479BE667...C47D08FFB10D4B8</code>.
The following code snippet demonstrates this:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs;

use libsecp256k1_rs::{ SecretKey, PublicKey };

#[allow(non_snake_case)]
fn main() {
    // Create the secret key &quot;1&quot;
    let k = SecretKey::from_hex(&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;).unwrap();
    // Generate the public key, P = k.G
    let pub_from_k = PublicKey::from_secret_key(&amp;k);
    let known_pub = PublicKey::from_hex(&quot;0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8&quot;).unwrap();
    // Compare it to the known value
    assert_eq!(pub_from_k, known_pub);
    println!(&quot;Ok&quot;)
}

</code></pre></pre>
<h3><a class="header" href="#creating-a-signature" id="creating-a-signature">Creating a Signature</a></h3>
<h4><a class="header" href="#approach-taken" id="approach-taken">Approach Taken</a></h4>
<p>Reversing ECC math multiplication (i.e. division) is pretty much infeasible when using properly chosen random values for your scalars ([<a href="https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work" title="StackOverflow: How does a Cryptographically Secure Random Number Generator Work?">5</a>],[<a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" title="Cryptographically Secure Pseudorandom Number Generator">6</a>]).
This property is called the <em>Discrete Log Problem</em>, and is used as the principle behind many cryptography and digital signatures. 
A valid digital signature is evidence that the person providing the signature knows the private key corresponding to the public key with which the message
is associated, or that they have solved the Discrete Log Problem. </p>
<p>The approach to creating signatures always follows this recipe:</p>
<ol>
<li>Generate a secret once-off number (called a <em>nonce</em>), $r$.</li>
<li>Create a public key, $R$ from $r$ (where $R = r.G$).</li>
<li>Send the following to Bob, your recipient - your message ($m$), $R$, and your public key ($P = k.G$).</li>
</ol>
<p>The actual signature is created by hashing the combination of all the public information above to create a <em>challenge</em>, $e$:
$$
e = H(R || P || m)
$$
The hashing function is chosen so that <em>e</em> has the same range as your private keys. In our case, we want something that
returns a 256-bit number, so SHA256 is a good choice.</p>
<p>Now the signature is constructed using your private information:
$$
s = r + ke 
$$
Bob can now also calculate $e$, since he already knows $m, R, P$. But he doesn't know your private key, or nonce.</p>
<p><strong>Note:</strong> When you construct the signature like this, it's known as a <a href="#schnorr-signatures">Schnorr signature</a>, which is discussed in 
a following section. There are other ways of constructing $s$, such as ECDSA [<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="Wikipedia: ECDSA">2</a>], which is used in Bitcoin.</p>
<p>But see this:</p>
<p>$$ sG = (r + ke)G $$</p>
<p>Multiply out the right-hand side:</p>
<p>$$ sG = rG + (kG)e ​$$</p>
<p>Substitute \(R = rG \) and \(P = kG \) and we have:
$$ sG = R + Pe ​$$</p>
<p>So Bob must just calculate the public key corresponding to the signature $\text{(}s.G\text{)}$ and check that it equals the right-hand side of the last
equation above $\text{(}R + P.e\text{)}$, all of which Bob already knows.</p>
<h4><a class="header" href="#why-do-we-need-the-nonce" id="why-do-we-need-the-nonce">Why do we Need the Nonce?</a></h4>
<p>Why do we need a nonce in the standard signature?</p>
<p>Let's say we naïvely sign a message $m$ with
$$
e = H(P || m)
$$
and then the signature would be \(s = ek \). </p>
<p>Now as before, we can check that the signature is valid:
$$
\begin{align}
sG &amp;= ekG \\
&amp;= e(kG) = eP
\end{align}
$$
So far so good. But anyone can read your private key now because $s$ is a scalar, so \(k = {s}/{e} \)
is not hard to do.
With the nonce you have to solve \( k = (s - r)/e \), but $r$ is unknown, so this is not a feasible calculation as long
as $r$ has been chosen randomly.</p>
<p>We can show that leaving off the nonce is indeed highly insecure:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{ Challenge};

#[allow(non_snake_case)]
fn main() {
    // Create a random private key
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    println!(&quot;My private key: {}&quot;, k);
    let P = PublicKey::from_secret_key(&amp;k);
    let m = Message::hash(b&quot;Meet me at 12&quot;).unwrap();
    // Challenge, e = H(P || m)
    let e = Challenge::new(&amp;[&amp;P, &amp;m]).as_scalar().unwrap();

    // Signature
    let s = e * k;

    // Verify the signature
    assert_eq!(PublicKey::from_secret_key(&amp;s), e*P);
    println!(&quot;Signature is valid!&quot;);
    // But let's try calculate the private key from known information
    let hacked = s * e.inv();
    assert_eq!(k, hacked);
    println!(&quot;Hacked key:     {}&quot;, k)
}

</code></pre></pre>
<h4><a class="header" href="#ecdh" id="ecdh">ECDH</a></h4>
<p>How do parties that want to communicate securely generate a shared secret for encrypting messages? One way is called
the Elliptic Curve Diffie-Hellman exchange (ECDH), which is a simple method for doing just this.</p>
<p>ECDH is used in many places, including the Lightning Network during channel negotiation [<a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md" title="BOLT #8: Encrypted and Authenticated Transport">3</a>].</p>
<p>Here's how it works. Alice and Bob want to communicate securely. A simple way to do this is to use each other's public keys and
calculate
$$
\begin{align}
S_a &amp;= k_a P_b \tag{Alice} \\
S_b &amp;= k_b P_a \tag{Bob} \\
\implies S_a = k_a k_b G &amp;\equiv S_b = k_b k_a G
\end{align}
$$</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{ SecretKey, PublicKey, thread_rng, Message };

#[allow(non_snake_case)]
fn main() {
    let mut rng = thread_rng();
    // Alice creates a public-private keypair
    let k_a = SecretKey::random(&amp;mut rng);
    let P_a = PublicKey::from_secret_key(&amp;k_a);
    // Bob creates a public-private keypair
    let k_b = SecretKey::random(&amp;mut rng);
    let P_b = PublicKey::from_secret_key(&amp;k_b);
    // They each calculate the shared secret based only on the other party's public information
    // Alice's version:
    let S_a = k_a * P_b;
    // Bob's version:
    let S_b = k_b * P_a;

    assert_eq!(S_a, S_b, &quot;The shared secret is not the same!&quot;);
    println!(&quot;The shared secret is identical&quot;)
}

</code></pre></pre>
<p>For security reasons, the private keys are usually chosen at random for each session (you'll see the term
<em>ephemeral</em> keys being used), but then we have the problem of not being sure the other party is who they say they
are (perhaps due to a man-in-the-middle attack [<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" title="Wikipedia: Man in the Middle Attack">4</a>]).</p>
<p>Various additional authentication steps can be employed to resolve this problem, which we won't get into here. </p>
<h2><a class="header" href="#schnorr-signatures" id="schnorr-signatures">Schnorr Signatures</a></h2>
<p>If you follow the crypto news, you'll know that that the new hotness in Bitcoin is Schnorr Signatures.</p>
<p align="center"><img src="./img/schnorr-meme.jpg" width="600" /></p>
<p>But in fact, they're old news! The Schnorr signature is considered the simplest digital signature scheme 
to be provably secure in a random oracle model. It is efficient and generates short signatures. 
It was covered by U.S. Patent 4,995,082, which expired in February 2008 [<a href="https://en.wikipedia.org/wiki/Schnorr_signature" title="Wikipedia: Schnorr Signature">7</a>].</p>
<h3><a class="header" href="#so-why-all-the-fuss" id="so-why-all-the-fuss">So why all the Fuss?</a></h3>
<p>What makes Schnorr signatures so interesting and <a href="#key-cancellation-attack">potentially dangerous</a>, is their simplicity. 
Schnorr signatures are <em>linear</em>, so you have some nice properties.</p>
<p>Elliptic curves have the multiplicative property. So if you have two scalars $x, y$ with corresponding points $X, Y$, 
the following holds:
$$
(x + y)G = xG + yG = X + Y 
$$
Schnorr signatures are of the form \( s = r + e.k \). This construction is linear too, so it fits nicely with
the linearity of elliptic curve math.</p>
<p>You saw this property in a <a href="#creating-a-signature">previous section</a>, when we were verifying the signature. Schnorr signatures' linearity 
makes it very attractive for, among others:</p>
<ul>
<li>signature aggregation;</li>
<li><a href="../../protocols/atomic-swaps/AtomicSwaps.html">atomic swaps</a>;</li>
<li><a href="../scriptless-scripts/introduction-to-scriptless-scripts.html">&quot;scriptless&quot; scripts</a>.</li>
</ul>
<h3><a class="header" href="#naïve-signature-aggregation" id="naïve-signature-aggregation">Naïve Signature Aggregation</a></h3>
<p>Let's see how the linearity property of Schnorr signatures can be used to construct a two-of-two multi-signature.</p>
<p>Alice and Bob want to cosign something (a Tari transaction, say) without having to trust each other; 
i.e. they need to be able to prove ownership of their respective keys, and the aggregate signature is
only valid if <em>both</em> Alice and Bob provide their part of the signature. </p>
<p>Assuming private keys are denoted \( k_i \) and public keys \( P_i \). If we ask Alice and Bob to each 
supply a nonce, we can try:
$$
\begin{align}
P_{agg} &amp;= P_a + P_b \\
e &amp;= H(R_a || R_b || P_a || P_b || m) \\
s_{agg} &amp;= r_a + r_b + (k_a + k_b)e \\
&amp;= (r_a + k_ae) + (r_b + k_ae) \\
&amp;= s_a + s_b
\end{align}
$$
So it looks like Alice and Bob can supply their own $R$, and anyone can construct the two-of-two signature 
from the sum of the $Rs$ and public keys. This does work:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{Schnorr, Challenge};

#[allow(non_snake_case)]
fn main() {
    // Alice generates some keys
    let (ka, Pa, ra, Ra) = get_keyset();
    // Bob generates some keys
    let (kb, Pb, rb, Rb) = get_keyset();
    let m = Message::hash(b&quot;a multisig transaction&quot;).unwrap();
    // The challenge uses both nonce public keys and private keys
    // e = H(Ra || Rb || Pa || Pb || H(m))
    let e = Challenge::new(&amp;[&amp;Ra, &amp;Rb, &amp;Pa, &amp;Pb, &amp;m]).as_scalar().unwrap();
    // Alice calculates her signature
    let sa = ra + ka * e;
    // Bob calculates his signature
    let sb = rb + kb * e;
    // Calculate the aggregate signature
    let s_agg = sa + sb;
    // S = s_agg.G
    let S = PublicKey::from_secret_key(&amp;s_agg);
    // This should equal Ra + Rb + e(Pa + Pb)
    assert_eq!(S, Ra + Rb + e*(Pa + Pb));
    println!(&quot;The aggregate signature is valid!&quot;)
}

#[allow(non_snake_case)]
fn get_keyset() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}

</code></pre></pre>
<p>But this scheme is not secure!</p>
<h3><a class="header" href="#key-cancellation-attack" id="key-cancellation-attack">Key Cancellation Attack</a></h3>
<p>Let's take the previous scenario again, but this time, Bob knows Alice's public key and nonce ahead of time, by
waiting until she reveals them. </p>
<p>Now Bob lies and says that his public key is \( P_b' = P_b - P_a \) and public nonce is \( R_b' = R_b - R_a \).</p>
<p>Note that Bob doesn't know the private keys for these faked values, but that doesn't matter.</p>
<p>Everyone assumes that \(s_{agg} = R_a + R_b' + e(P_a + P_b') \) as per the aggregation scheme.</p>
<p>But Bob can create this signature himself: 
$$
\begin{align}
s_{agg}G &amp;= R_a + R_b' + e(P_a + P_b') \\
&amp;= R_a + (R_b - R_a) + e(P_a + P_b - P_a) \\
&amp;= R_b + eP_b \\
&amp;= r_bG + ek_bG \\
\therefore s_{agg} &amp;= r_b + ek_b = s_b
\end{align}
$$</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{Schnorr, Challenge};

#[allow(non_snake_case)]
fn main() {
    // Alice generates some keys
    let (ka, Pa, ra, Ra) = get_keyset();
    // Bob generates some keys as before
    let (kb, Pb, rb, Rb) = get_keyset();
    // ..and then publishes his forged keys
    let Pf = Pb - Pa;
    let Rf = Rb - Ra;

    let m = Message::hash(b&quot;a multisig transaction&quot;).unwrap();
    // The challenge uses both nonce public keys and private keys
    // e = H(Ra || Rb' || Pa || Pb' || H(m))
    let e = Challenge::new(&amp;[&amp;Ra, &amp;Rf, &amp;Pa, &amp;Pf, &amp;m]).as_scalar().unwrap();

    // Bob creates a forged signature
    let s_f = rb + e * kb;
    // Check if it's valid
    let sG = Ra + Rf + e*(Pa + Pf);
    assert_eq!(sG, PublicKey::from_secret_key(&amp;s_f));
    println!(&quot;Bob successfully forged the aggregate signature!&quot;)
}

#[allow(non_snake_case)]
fn get_keyset() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}

</code></pre></pre>
<h3><a class="header" href="#better-approaches-to-aggregation" id="better-approaches-to-aggregation">Better Approaches to Aggregation</a></h3>
<p>In the <a href="#key-cancellation-attack">Key Cancellation Attack</a>, Bob didn't know the private keys for his published $R$ and $P$ values. We could defeat Bob
by asking him to sign a message proving that he <em>does</em> know the private keys.</p>
<p>This works, but it requires another round of messaging between parties, which is not conducive to a great user experience.</p>
<p>A better approach would be one that incorporates one or more of the following features:</p>
<ul>
<li>It must be provably secure in the plain public-key model, without having to prove knowledge of secret keys, as we might have asked Bob to do in the <a href="#na%C3%AFve-signature-aggregation">naïve</a> approach.</li>
<li>It should satisfy the normal Schnorr equation, i.e. the resulting signature can be verified with an expression of the form \( R + e X \).</li>
<li>It allows for Interactive Aggregate Signatures (IAS), where the signers are required to cooperate.</li>
<li>It allows for Non-interactive Aggregate Signatures (NAS), where the aggregation can be done by anyone.</li>
<li>It allows each signer to sign the same message, $m$.</li>
<li>It allows each signer to sign their own message, \( m_i \).</li>
</ul>
<h2><a class="header" href="#musig" id="musig">MuSig</a></h2>
<p>MuSig is a recently proposed ([<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" title="Blockstream: Key Aggregation for Schnorr Signatures">8</a>],[<a href="https://eprint.iacr.org/2018/068.pdf" title="Simple Schnorr Multi-signatures with Applications to Bitcoin">9</a>]) simple signature aggregation scheme that satisfies all of the properties in the preceding section.</p>
<h3><a class="header" href="#musig-demonstration" id="musig-demonstration">MuSig Demonstration</a></h3>
<p>We'll demonstrate the interactive MuSig scheme here, where each signatory signs the same message. 
The scheme works as follows:</p>
<ol>
<li>Each signer has a public-private key pair, as before.</li>
<li>Each signer shares a commitment to their public nonce (we'll skip this step in this demonstration). This step is
necessary to prevent certain kinds of rogue key attacks [<a href="https://eprint.iacr.org/2018/417.pdf" title="On the Security of Two-round Multi-signatures">10</a>].</li>
<li>Each signer publishes the public key of their nonce, \( R_i \).</li>
<li>Everyone calculates the same &quot;shared public key&quot;, $X$ as follows: </li>
</ol>
<p>$$
\begin{align}
\ell &amp;= H(X_1 || \dots || X_n) \\
a_i &amp;= H(\ell || X_i) \\
X &amp;= \sum a_i X_i \\
\end{align}
$$</p>
<p>Note that in the preceding ordering of public keys, some deterministic convention should be used, such as the lexicographical
order of the serialized keys.</p>
<ol>
<li>Everyone also calculates the shared nonce, \( R = \sum R_i \).</li>
<li>The challenge, $e$ is \( H(R || X || m) \).</li>
<li>Each signer provides their contribution to the signature as:</li>
</ol>
<p>$$
s_i = r_i + k_i a_i e
$$</p>
<p>Notice that the only departure here from a standard Schnorr signature is the inclusion of the factor \( a_i \).</p>
<p>The aggregate signature is the usual summation, \( s = \sum s_i \).</p>
<p>Verification is done by confirming that as usual:
$$
sG \equiv R + e X \
$$
Proof:
$$
\begin{align}
sG &amp;= \sum s_i G \\
&amp;= \sum (r_i + k_i a_i e)G \\
&amp;= \sum r_iG + k_iG a_i e \\
&amp;= \sum R_i + X_i a_i e \\
&amp;= \sum R_i + e \sum a_i X_i \\
&amp;= R + e X \\
\blacksquare
\end{align}
$$
Let's demonstrate this using a three-of-three multisig:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{ SecretKey, PublicKey, thread_rng, Message };
use secp256k1::schnorr::{ Challenge };

#[allow(non_snake_case)]
fn main() {
    let (k1, X1, r1, R1) = get_keys();
    let (k2, X2, r2, R2) = get_keys();
    let (k3, X3, r3, R3) = get_keys();

    // I'm setting the order here. In general, they'll be sorted
    let l = Challenge::new(&amp;[&amp;X1, &amp;X2, &amp;X3]);
    // ai = H(l || p)
    let a1 = Challenge::new(&amp;[ &amp;l, &amp;X1 ]).as_scalar().unwrap();
    let a2 = Challenge::new(&amp;[ &amp;l, &amp;X2 ]).as_scalar().unwrap();
    let a3 = Challenge::new(&amp;[ &amp;l, &amp;X3 ]).as_scalar().unwrap();
    // X = sum( a_i X_i)
    let X = a1 * X1 + a2 * X2 + a3 * X3;

    let m = Message::hash(b&quot;SomeSharedMultiSigTx&quot;).unwrap();

    // Calc shared nonce
    let R = R1 + R2 + R3;

    // e = H(R || X || m)
    let e = Challenge::new(&amp;[&amp;R, &amp;X, &amp;m]).as_scalar().unwrap();


    // Signatures
    let s1 = r1 + k1 * a1 * e;
    let s2 = r2 + k2 * a2 * e;
    let s3 = r3 + k3 * a3 * e;
    let s = s1 + s2 + s3;

    //Verify
    let sg = PublicKey::from_secret_key(&amp;s);
    let check = R + e * X;
    assert_eq!(sg, check, &quot;The signature is INVALID&quot;);
    println!(&quot;The signature is correct!&quot;)
}

#[allow(non_snake_case)]
fn get_keys() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}
</code></pre></pre>
<h3><a class="header" href="#security-demonstration" id="security-demonstration">Security Demonstration</a></h3>
<p>As a final demonstration, let's show how MuSig defeats the cancellation attack from the <a href="#na%C3%AFve-signature-aggregation">naïve</a> signature scheme. 
Using the same idea as in the <a href="#key-cancellation-attack">Key Cancellation Attack</a> section, Bob has provided fake values for his
nonce and public keys:
$$
\begin{align}
R_f &amp;= R_b - R_a \\
X_f &amp;= X_b - X_a \\
\end{align}
$$
This leads to both Alice and Bob calculating the following &quot;shared&quot; values:
$$
\begin{align}
\ell &amp;= H(X_a || X_f) \\
a_a &amp;= H(\ell || X_a) \\
a_f &amp;= H(\ell || X_f) \\
X &amp;= a_a X_a + a_f X_f \\
R &amp;= R_a + R_f (= R_b) \\
e &amp;= H(R || X || m)
\end{align}
$$
Bob then tries to construct a unilateral signature following MuSig:
$$
s_b = r_b + k_s e
$$
Let's assume for now that \( k_s \) doesn't need to be Bob's private key, but that he can derive it using information
he knows. For this to be a valid signature, it must verify to \( R + eX \). So therefore:
$$
\begin{align}
s_b G          &amp;= R + eX \\
(r_b + k_s e)G &amp;= R_b + e(a_a X_a + a_f X_f) &amp; \text{The first term looks good so far}\\
&amp;= R_b + e(a_a X_a + a_f X_b - a_f X_a) \\
&amp;= (r_b + e a_a k_a + e a_f k_b - e a_f k_a)G &amp; \text{The r terms cancel as before} \\
k_s e &amp;=  e a_a k_a + e a_f k_b - e a_f k_a &amp; \text{But nothing else is going away}\\
k_s &amp;= a_a k_a + a_f k_b - a_f k_a \\<br />
\end{align}
$$
In the previous attack, Bob had all the information he needed on the right-hand side of the analogous calculation. In MuSig,
Bob must somehow know Alice's private key and the faked private key (the terms don't cancel anymore) in order to create a unilateral signature,
and so his cancellation attack is defeated.</p>
<h3><a class="header" href="#replay-attacks" id="replay-attacks">Replay Attacks!</a></h3>
<p>It's critical that a new nonce be chosen for every signing ceremony. The best way to do this is to make use of a
cryptographically secure (pseudo-)random number generator (CSPRNG).</p>
<p>But even if this is the case, let's say an attacker can trick us into signing a new message by &quot;rewinding&quot; the signing
ceremony to the point where partial signatures are generated. At this point, the attacker provides a different message,
\( e' = H(...||m') \) to sign. Not suspecting any foul play, each party calculates their partial signature:</p>
<p>$$ s'_i = r_i + a_i k_i e' $$
However, the attacker still has access to the first set of signatures: \( s_i = r_i + a_i k_i e \). He now simply
subtracts them:
$$
\begin{align}
s'_i - s_i &amp;= (r_i + a_i k_i e') - (r_i + a_i k_i e) \\
&amp;= a_i k_i (e' - e) \\
\therefore k_i &amp;= \frac{s'_i - s_i}{a_i(e' - e)}
\end{align}
$$
Everything on the right-hand side of the final equation is known by the attacker and thus he can trivially extract everybody's private key.
It's difficult to protect against this kind of attack. One way to is make it difficult (or impossible) to stop and
restart signing ceremonies. If a multi-sig ceremony gets interrupted, then you need to start from step one again. This
is fairly unergonomic, but until a more robust solution comes along, it may be the best we have!</p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<p>[<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" title="Wikipedia RSA Cryptography">1</a>] Wikipedia: &quot;RSA (Cryptosystem)&quot; [online]. Available: <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">https://en.wikipedia.org/wiki/RSA_(cryptosystem)</a>. Date accessed: 
2018‑10‑11.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="Wikipedia: ECDSA">2</a>] Wikipedia: &quot;Elliptic Curve Digital Signature Algorithm&quot; [online]. Available: 
<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm</a>. Date accessed: 2018‑10‑11.</p>
<p>[<a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md" title="BOLT #8: Encrypted and Authenticated Transport">3</a>] Github: &quot;BOLT #8: Encrypted and Authenticated Transport, Lightning RFC&quot; [online].<br />
Available: <a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md">https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md</a>. Date accessed: 2018‑10‑11.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" title="Wikipedia: Man in the Middle Attack">4</a>] Wikipedia: &quot;Man in the Middle Attack&quot; [online].
Available: <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">https://en.wikipedia.org/wiki/Man-in-the-middle_attack</a>. Date accessed: 2018‑10‑11.</p>
<p>[<a href="https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work" title="StackOverflow: How does a Cryptographically Secure Random Number Generator Work?">5</a>] StackOverflow: &quot;How does a Cryptographically Secure Random Number Generator Work?&quot; [online]. Available: 
<a href="https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work">https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work</a>. 
Date accessed: 2018‑10‑11.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" title="Cryptographically Secure Pseudorandom Number Generator">6</a>] Wikipedia: &quot;Cryptographically Secure Pseudorandom Number Generator&quot; [online]. Available: 
<a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator</a>. Date accessed: 2018‑10‑11.</p>
<p>[<a href="https://en.wikipedia.org/wiki/Schnorr_signature" title="Wikipedia: Schnorr Signature">7</a>] Wikipedia: &quot;Schnorr Signature&quot; [online]. Available: <a href="https://en.wikipedia.org/wiki/Schnorr_signature">https://en.wikipedia.org/wiki/Schnorr_signature</a>.
Date accessed: 2018‑09‑19.</p>
<p>[<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" title="Blockstream: Key Aggregation for Schnorr Signatures">8</a>] Blockstream: &quot;Key Aggregation for Schnorr Signatures&quot; [online]. Available: 
<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html">https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html</a>. Date accessed: 2018‑09‑19.</p>
<p>[<a href="https://eprint.iacr.org/2018/068.pdf" title="Simple Schnorr Multi-signatures with Applications to Bitcoin">9</a>] G. Maxwell, A. Poelstra, Y. Seurin and P. Wuille, &quot;Simple Schnorr Multi-signatures with Applications to Bitcoin&quot; [online]. Available: <a href="https://eprint.iacr.org/2018/068.pdf">https://eprint.iacr.org/2018/068.pdf</a>. Date accessed: 2018‑09‑19.</p>
<p>[<a href="https://eprint.iacr.org/2018/417.pdf" title="On the Security of Two-round Multi-signatures">10</a>] M. Drijvers, K. Edalatnejad, B. Ford, E. Kiltz, J. Loss, G. Neven and I. Stepanovs, 
&quot;On the Security of Two-round Multi-signatures&quot;, Cryptology ePrint Archive, Report 2018/417 [online]. 
Available: <a href="https://eprint.iacr.org/2018/417.pdf">https://eprint.iacr.org/2018/417.pdf</a>. Date accessed: 2019‑02‑21.</p>
<h2><a class="header" href="#contributors" id="contributors">Contributors</a></h2>
<ul>
<li><a href="https://github.com/CjS77">https://github.com/CjS77</a></li>
<li><a href="https://github.com/SWvHeerden">https://github.com/SWvHeerden</a></li>
<li><a href="https://github.com/hansieodendaal">https://github.com/hansieodendaal</a></li>
<li><a href="https://github.com/neonknight64">https://github.com/neonknight64</a></li>
<li><a href="https://github.com/anselld">https://github.com/anselld</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../cryptography/crypto-1/sources/PITCHME.link.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../../cryptography/crypto-1/sources/PITCHME.link.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-115476091-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Initialize mermaid -->
        <script src="../../theme/js/mermaid.min.js" type="text/javascript" charset="utf-8"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
